<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Monica</title>
  <icon>https://www.gravatar.com/avatar/299914b189a518471ea20de4e696e359</icon>
  <subtitle>Whatever It Takes</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/MonicaDan/monicadan.github.com.git/"/>
  <updated>2017-10-23T04:19:37.124Z</updated>
  <id>https://github.com/MonicaDan/monicadan.github.com.git/</id>
  
  <author>
    <name>MonicaDan</name>
    <email>1223999657@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JS显式类型转换和隐式类型转换</title>
    <link href="https://github.com/MonicaDan/monicadan.github.com.git/2017/10/23/JS%E6%98%BE%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%92%8C%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <id>https://github.com/MonicaDan/monicadan.github.com.git/2017/10/23/JS显式类型转换和隐式类型转换/</id>
    <published>2017-10-23T04:16:56.000Z</published>
    <updated>2017-10-23T04:19:37.124Z</updated>
    
    <content type="html"><![CDATA[<p>这是一篇关于最基础的js类型转换的文章，正所谓基础中的基础就得必须吃透它！<br><a id="more"></a></p><h3 id="显式类型转换"><a href="#显式类型转换" class="headerlink" title="显式类型转换"></a>显式类型转换</h3><p><strong>以下方法均有一个共同点：如果元素的开头有若干个空格或加号或减号，不影响对元素的判断。</strong></p><ul><li><strong>Number( )</strong><br>将目标元素类型转为数字类型；从左往右判断每个元素，除了开头的若干个空格或加号或减号，若在此以后出现了非数字元素就返回NaN。<br>布尔值中的false为0；true为1；<br>元素大于1的数组、函数返回NaN；<br>数组中只包含一个元素其内容为数字或内容为数字的字符串，返回该数字；<br>空数组、空字符串、null、undefined等返回0；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">alert(Number(&apos; 45&apos;)); //弹出45 </div><div class="line">alert(Number(&apos; +45&apos;)); //弹出NaN   </div><div class="line">alert(Number(&apos;+hh45&apos;));  //弹出NaN </div><div class="line">alert(Number(true)); //弹出1</div><div class="line">alert(Number(false)); //弹出0</div><div class="line">alert(Number([45,78,78])); //弹出NaN </div><div class="line">alert(Number([&apos;45&apos;])); //弹出45</div><div class="line">alert(Number([])); //弹出0</div><div class="line">alert(Number(&apos;&apos;)); //弹出0</div></pre></td></tr></table></figure><ul><li><strong>parseInt( )</strong><br>将目标元素类型转为整型数字类型；从左往右判断每个元素，除了开头的若干个空格或加号或减号，直到出现非数字元素就停止，返回以上值。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">alert(parseInt(b)); // 150</div><div class="line">alert(parseFloat(b));//   150</div><div class="line">var fc = function () &#123; &#125;;</div><div class="line">alert(parseInt(fc));  //NaN</div><div class="line">var c = &apos;18.22 元&apos;;</div><div class="line">alert(Number(c)); //NaN</div><div class="line">alert(parseInt(c, 10));  //转成了18 第二个参数为转化成的进制</div><div class="line">alert(parseFloat(c));   //转成了18.55</div></pre></td></tr></table></figure></li></ul><h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><ul><li><strong>+</strong>    返回字符串</li><li><strong>-  *  /  % </strong>  返回数字</li><li><strong>++ &nbsp; - -</strong> 返回数字</li><li><blockquote><p>、&lt;、&lt;=、&gt;= 返回布尔值</p></blockquote></li><li><strong>! 取反</strong> 返回布尔值</li><li><strong>==</strong>   返回布尔值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">console.log(&apos;200&apos;+3); //2003</div><div class="line">console.log(&apos;200&apos;*3); //600</div><div class="line">console.log(&apos;100&apos;&gt;9); //true</div><div class="line">console.log(&apos;100&apos;&gt;&apos;9&apos;); //false 字符串按位比较1&lt;9</div><div class="line">console.log(&apos;10&apos;==10);//true 把两个转成同类型</div></pre></td></tr></table></figure><p>对于判断两个参数的类型是否相等应当使用<strong>===</strong>来判断；此时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">console.log(&apos;45&apos;===45); //false</div></pre></td></tr></table></figure></p><p><strong>NaN比较特殊：</strong><br>NaN :  表示 not a number的<strong>数字类型</strong>。即NaN是数字类型 ; </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">console.log(typeof(NaN));  //number</div><div class="line">``` </div><div class="line">所有的东西都可以和自己比较===全部为真；但除了NaN。</div></pre></td></tr></table></figure><p>conole.log(NaN===NaN);  //false<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">**js判断数据类型：**</div></pre></td></tr></table></figure></p><p>if(typeof a=’number’&amp;&amp;a===a){<br>// a===a 排除NaN的问题<br>alert(a+’是数字’);<br>}else if(typeof a===’String’){<br>alert(a+’是字符串’);<br>};<br>``` </p><p><strong>isNaN( );</strong> 非数字判断；<br><code>isNaN(&#39;123&#39;);</code>  结果为true；<br>这个过程其实先进行了<code>Number(&#39;123&#39;); //123</code>的运算；将字符串转为数字或者NaN之后，再判断是不是数字。<code>isNaN([ ]); //false</code> 空数组转为数字类型为0，非数字返回NaN。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一篇关于最基础的js类型转换的文章，正所谓基础中的基础就得必须吃透它！&lt;br&gt;
    
    </summary>
    
      <category term="web dev" scheme="https://github.com/MonicaDan/monicadan.github.com.git/categories/web-dev/"/>
    
    
      <category term="js" scheme="https://github.com/MonicaDan/monicadan.github.com.git/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>JSON小结</title>
    <link href="https://github.com/MonicaDan/monicadan.github.com.git/2017/10/20/JSON%E5%B0%8F%E7%BB%93/"/>
    <id>https://github.com/MonicaDan/monicadan.github.com.git/2017/10/20/JSON小结/</id>
    <published>2017-10-20T14:36:11.000Z</published>
    <updated>2017-10-23T04:20:23.766Z</updated>
    
    <content type="html"><![CDATA[<p>最近翻阅了一本《深入理解JavaScript》颇有感触，此篇文章就当是本小白对JSON的重新摸索吧。<br><a id="more"></a></p><h2 id="一、所以，JSON是什么？"><a href="#一、所以，JSON是什么？" class="headerlink" title="一、所以，JSON是什么？"></a>一、所以，JSON是什么？</h2><p>   JSON是<code>JavaScript Object Notation</code>的缩写，是一种纯文本格式的数据存储。它被广泛地运用于Web服务的传输媒介、配置文件等。<br>官方网站：<br><a href="http://www.json.org/" title="JSON官网" target="_blank" rel="external">JSON英文官网</a><br><a href="http://www.json.org.cn/" title="JSON中国" target="_blank" rel="external">JSON中国</a></p><hr><h2 id="二、JSON的数据格式呢？"><a href="#二、JSON的数据格式呢？" class="headerlink" title="二、JSON的数据格式呢？"></a>二、JSON的数据格式呢？</h2><p>JSON的语法集是javaScript表达式语法的一个子集。</p><hr><p><strong>普通格式例子</strong>：</p><blockquote><p>  {<br>          &nbsp;&nbsp; “firstName”:”Dan”,<br>         &nbsp;&nbsp; “lastName”:”Monica”,<br>        &nbsp; &nbsp; “born”:”1995”,<br>      &nbsp;&nbsp; “married”:false,<br>     &nbsp;&nbsp;  “friends”:[“Jason”,”Jasper”,”Yamap”]<br>  }</p></blockquote><p><strong>嵌套格式</strong>：</p><blockquote><p>{<br>    &nbsp;”person”:{<br>          &nbsp;&nbsp;&nbsp; &nbsp;    “name”:”MonicaDan”,<br>                        &nbsp;&nbsp;&nbsp; &nbsp;  “age”:21,<br>                           &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;”friends”:[“Jason”,”Jasper”,”Yamap”],<br>         &nbsp;&nbsp;&nbsp; &nbsp;   “head”:{<br>              &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;  “hair”:{<br>                 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;  &nbsp;&nbsp;   “color”:”black”,<br>         &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;  &nbsp;&nbsp;  “length”:”long”  },<br>    &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;”eyes”:”brown”    &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<br>    &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;   }<br>   }</p></blockquote><hr><p>JSON使用js表达式<strong>结构</strong> ：</p><ol><li>名称/值”对的集合</li></ol><blockquote><p> “不同的编程语言中，它被理解为对象（object），纪录（record），结构（struct），字典（dictionary），哈希表（hashtable），有键列表（keyed list），或者关联数组 （associative array）”</p></blockquote><ol><li>值的有序列表</li></ol><blockquote><p>  在大部分语言中，它被实现为数组（array），矢量（vector），列表（list），序列（sequence）。</p></blockquote><hr><p><strong>原则</strong></p><ul><li>字符串必须使用双引号，绝对不能使用单引号，否则无效。</li><li>属性名（键名）也必须使用双引号。 </li><li>值为null时，null必须为小写。写成Null为错误。</li></ul><hr><p><strong>形式</strong></p><ul><li>对象(object)是一个无序的 <code>键/值</code> 对 集合。一个对象以   <strong><code>{</code></strong>  （左括号）开   始，  <strong><code>}</code></strong> （右括号）结束。<ul><li>每个“键名”后跟一个“<code>:</code>”（冒号）；</li><li><code>键/值</code>  对 之间使用“<code>,</code>”（逗号）分隔。 </li></ul></li><li>数组（array） 是值（value）的有序集合。<ul><li>一个数组以 <strong><code>[</code></strong> （左中括号）开始，  <strong><code>]</code></strong> （右中括号）结束。</li><li>值之间使用“,”（逗号）分隔。 </li></ul></li><li><p>值（value） 可以是 <strong>双引号</strong>括起来的<code>字符串（string）</code> 、<code>数值(number)</code>、<code>布尔值</code>、 <code>null</code>、<code>对象（object）或者数组（array）</code>。这些结构可以嵌套。 </p></li><li><p>字符串（string） 是由<strong>双引号</strong>包围的任意数量Unicode字符的集合，使用反斜线<strong>转义</strong>。 </p></li></ul><hr><p><strong>转义</strong> </p><p>举一个巨简单的例子!<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">&quot;promo&quot;:&quot;Say &quot;Bob&apos;s best!&quot; at checkout for free 8oz bag of kiddle.&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>应改成(加入转义字符)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">&quot;promo&quot;:&quot;Say \&quot; Bob&apos;s best!\&quot;at checkout for free 8oz bag of kiddle.&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>注意”\”转义需要两个”\”，即用” \ \” 来转义”\”:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//错误：(此处的\为转义字符，解析后不显示此\)</div><div class="line">&#123;</div><div class="line">&quot;location&quot; : &quot;C : \ yunpan&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">// 正确：(第一个\为转义字符，第二个为路径写法中的\，解析后只显示一个\)</div><div class="line">&#123;</div><div class="line">&quot;location&quot;:&quot;C : \ \ yupan&quot;</div><div class="line">&#125;</div><div class="line">```  </div><div class="line"></div><div class="line">好啦，总结一下常见的转义符 ( **&quot;\&quot;叫做反斜线，&quot;/&quot;叫做斜线，绝对不要搞混！！** )：</div><div class="line">``` </div><div class="line">\&apos;(一个单引号)</div><div class="line">\&quot;(一个双引号)</div><div class="line">\\(一个反斜线字符 \ )</div><div class="line">\/(正斜线)</div><div class="line">\b(退格符，backspace)</div><div class="line">\f(换页符，跳到下一页开头)</div><div class="line">\t(制表符，跳到下一个TAB的位置)</div><div class="line">\n(换行符，跳到下一行)</div><div class="line">\r(回车符，从当前位置移到本行开头)</div><div class="line">\u 后面跟十六进制字符(如笑脸表情\u263A)</div><div class="line">\0 (表示null)</div><div class="line">\? (表示一个?)</div><div class="line">```   </div><div class="line">---</div><div class="line">改写错误：</div></pre></td></tr></table></figure><p>{<br>“story” : “\t Once upon a time , in a far away land \n there lived a princess”<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">正确的写法：将需要转义的字符进行转义，主要是对\进行转义。</div></pre></td></tr></table></figure></p><p>{<br>“story” : “\t Once upon a time , in a far away land \n there lived a princess”<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">---------</div><div class="line"></div><div class="line"> </div><div class="line">## 三、JSON.stringify(value,replacer?,space?)</div><div class="line">   JSON.stringify( )将JS值value转换成JSON字符串，其中replacer和space是可选参数。</div><div class="line">###  (一) JSON.stringify(value);</div></pre></td></tr></table></figure></p><p> <script><br> var a={a:[45,87,26], b:’ok’, c:false,d:422};<br> document.write( “运行结果：” + JSON.stringify(a));<br></script><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">结果：</div></pre></td></tr></table></figure></p><p>运行结果：{“a”:[45,87,26],”b”:”ok”,”c”:false,”d”:422}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">###  (二)可选参数replacer用于替换前参数value。</div><div class="line"> 如果 replacer 为函数，则 JSON.stringify 将调用该函数，并传入每个成员的键和值。使用返回值而不是原始值。如果此函数返回 undefined，则排除成员。根对象的键是一个空字符串：&quot;&quot;。</div><div class="line"> </div><div class="line"> - **replacer作为节点访问函数**  </div><div class="line"> 会在值被转为字符之前转换树节点的值。</div></pre></td></tr></table></figure></p><p><script><br>     function replacer (key,value){<br>            if (typeof value ===’number’){<br>                value = 2*value;<br>            }<br>            return value;<br>        }<br>        console.log( JSON.stringify({a:4,b:[1,2]},replacer))  ;<br></script><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">点击运行，观察控制台结果：</div></pre></td></tr></table></figure></p><p> {“a”:8,”b”:[2,4]}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">--------------------</div><div class="line">如果 replacer 是一个数组，则仅转换该数组中具有键值的成员。成员的转换顺序与键在数组中的顺序一样。当 value 参数也为数组时，将忽略 replacer 数组。</div><div class="line"></div><div class="line"> - **replacer作为属性键白名单**  </div><div class="line"></div><div class="line">&gt;   用于隐藏非数组对象内属性不在这个列表中的所有属性。----《深入理解JavaScript》</div><div class="line"></div><div class="line">看不懂啊！！我研究了很多遍最后弄懂了！！ ![这里写图片描述](http://img.blog.csdn.net/20170926200323857?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTW9uaWNhX0Rhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)![这里写图片描述](http://img.blog.csdn.net/20170926200323857?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTW9uaWNhX0Rhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)![这里写图片描述](http://img.blog.csdn.net/20170926200323857?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTW9uaWNhX0Rhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)</div><div class="line"></div><div class="line">将此处的replacer理解为白名单，白名单与黑名单对立，“自己人”。value部分如果有数组对象，白名单对该数组对象没隐藏作用。“这个列表”就是replacer部分的内容、白名单内容。</div><div class="line"></div><div class="line">引用的这句话的意思是：</div><div class="line"> 1.value部分有数组对象，白名单**无效**。</div><div class="line"> 2.value部分无数组对象，和白名单相同的属性**不会**被过滤掉。 </div><div class="line"> </div><div class="line">**value中没数组对象：**</div><div class="line">在控制台输入：（属性bar是自己人，value中的属性foo被我们恶狠狠地踢走，哼 ！）</div></pre></td></tr></table></figure></p><blockquote><p>JSON.stringify({foo:1,bar:{foo:1,bar:1}} , [‘bar’] )<br>//结果为：（foo不在白名单中，所以隐藏掉了foo ）<br>“{“bar”:{“bar”:1}}”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">自己人换成foo，不留情面地踢掉bar，value改变：</div><div class="line">``` </div><div class="line">&gt;JSON.stringify(&#123;foo:1,bar:&#123;foo:1,bar:1&#125;&#125;,[&apos;foo&apos;])</div><div class="line">结果：</div><div class="line">&quot;&#123;&quot;foo&quot;:1&#125;&quot;</div></pre></td></tr></table></figure></p></blockquote><p><strong>value中有数组对象：</strong>白名单无效，自己人失去特权喽。。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;JSON.stringify([&apos;a&apos;,&apos;b&apos;],[&apos;a&apos;])</div><div class="line"> &quot;[&quot;a&quot;,&quot;b&quot;]&quot;</div></pre></td></tr></table></figure><h3 id="三-可选参数space"><a href="#三-可选参数space" class="headerlink" title="(三)可选参数space"></a>(三)可选参数space</h3><p> space会影响输出的格式。没了space，字符串转换好的结果单行显示。使用space可以插入新行并且可以通过数组和对象的嵌套增加缩进。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">console.log(JSON.stringify(&#123;a:0,b:[&apos;\n&apos;],c:454&#125;));</div><div class="line">&#123;&quot;a&quot;:0,&quot;b&quot;:[&quot;\n&quot;],&quot;c&quot;:454&#125;</div></pre></td></tr></table></figure><p> <strong>space缩进</strong>的两种方式：<br><strong>1.</strong>  <strong>数字</strong> <em>为space设置一个数字</em>  将数字乘上对应量级的缩进，并用对应多的空格来缩进。</p><p>  缩进数字不同的对比：<br><img src="http://img.blog.csdn.net/20170926205015857?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTW9uaWNhX0Rhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>replacer的设置不同：</p><p> <img src="http://img.blog.csdn.net/20170926205248014?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTW9uaWNhX0Rhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p><strong>space小于0的解释为0，大于10的解释为10。</strong> </p><p>上图！<br><img src="http://img.blog.csdn.net/20170926205948302?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTW9uaWNhX0Rhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>再来一个！<br><img src="http://img.blog.csdn.net/20170926210005790?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTW9uaWNhX0Rhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p><strong>2.字符</strong><br>使用给定的字符为每个层级缩进。只有前10个字符会被用到：<br><img src="http://img.blog.csdn.net/20170926210618262?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTW9uaWNhX0Rhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>超出10个字符： </p><p><img src="http://img.blog.csdn.net/20170926210727500?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTW9uaWNhX0Rhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"> </p><p>###(四)被忽视的细节<br>在一个对象中，JSON.stringify( )只考虑了自己的枚举属性，而忽视了对象自身不可枚举属性obj.foo 。JSON.stringify( )将一个不被JSON支持的值（如函数和undefined）解析成什么取决于在哪儿遇见他们。<br>不被支持的值，在JSON.stringify( )之后返回的是一个undefined而不是一个string<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">//此处返回undefined</div><div class="line">&gt;JSON.stringify(function( )&#123; &#125;);</div><div class="line">undeified</div></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">//不支持的属性直接被忽视</div><div class="line">&gt;JSON.stringify(&#123;foo:function(  )&#123;  &#125; &#125; );</div><div class="line">&apos;&#123;&#125;&apos;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">//不被支持的值在数组中解析成null</div><div class="line">&gt;JSON.stringify( [ function( )&#123; &#125;] ); </div><div class="line">&apos;[null]&apos;</div></pre></td></tr></table></figure><p>###(五)toJSON( )方法<br>获得字符串化的值。<br><strong>字符串化Date：</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">//toJSON()方法将当前日期字符串化</div><div class="line">var d=new Date( );</div><div class="line">console.log(d.toJSON( ));</div><div class="line">&lt;/script&gt;</div><div class="line">```  </div><div class="line"> 内置的JSON方法有：</div></pre></td></tr></table></figure><p>Boolean.prototype.toJSON( );<br>Number.prototype.toJSON( );<br>String.prototype.toJSON( );<br>Date.prototype.toJSON( );<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">------------------------------</div><div class="line">## 四、JSON.parse(text,reviver?)</div><div class="line">用来解析JSON的数据，然后返回对应的值。需要注意的是使用单引号将JSON对象圈起来。</div><div class="line">###（一）</div></pre></td></tr></table></figure></p><blockquote><p>JSON.parse(‘“hello”‘);<br> “hello”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p><p>JSON.parse(“ ‘hello’ “);<br> SyntaxError: JSON.parse: unexpected character at line 1 column 1 of the JSON data<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">对象、数组</div></pre></td></tr></table></figure></p><p>JSON.parse(‘{“a”:”apple”,”b”:”banana”}’);<br> Object {“a”:”apple”,”b”:”banana”}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p></blockquote><p>JSON.parse(‘[1,2,3,4]’);<br>Array [1,2,3,4]</p><pre><code>###(二)reviver参数reviver为可选参数，它是一个节点访问函数，将为对象的每个成员调用此函数。      function okReviver (key,value){       document.write( key );     document.write(&quot; &lt;br&gt;&quot;)    } ----</code></pre><p>//调用此函数<br>    JSON.parse(‘{“1”: 1, “2”: 2, “3”: {“4”: 4, “5”: {“6”: 6,”7”:7}}}’, okReviver);</p><p>```<br><br><br>好啦！<br><br><br>继续加油咯！！！<img src="http://img.blog.csdn.net/20170927171745813?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTW9uaWNhX0Rhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近翻阅了一本《深入理解JavaScript》颇有感触，此篇文章就当是本小白对JSON的重新摸索吧。&lt;br&gt;
    
    </summary>
    
      <category term="web dev" scheme="https://github.com/MonicaDan/monicadan.github.com.git/categories/web-dev/"/>
    
    
  </entry>
  
  <entry>
    <title>hexo+GitHub创建属于自己的博客</title>
    <link href="https://github.com/MonicaDan/monicadan.github.com.git/2017/10/20/hexo-GitHub%E5%88%9B%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <id>https://github.com/MonicaDan/monicadan.github.com.git/2017/10/20/hexo-GitHub创建属于自己的博客/</id>
    <published>2017-10-20T14:17:39.000Z</published>
    <updated>2017-10-23T04:21:15.851Z</updated>
    
    <content type="html"><![CDATA[<p>  大家好！我是MonicaDan！ 前几天使用了hexo和GitHub创建属于自己的博客，这就算是一个总结吧~ 开始咯~~</p><a id="more"></a><h2 id="一、关于hexo"><a href="#一、关于hexo" class="headerlink" title="一、关于hexo"></a>一、关于hexo</h2><p><code>Hexo</code>是一个开源的静态博客生成器,用<code>nodejs</code>开发,作者是台湾大学生<code>tommy351</code>。</p><h2 id="二、-话不多说，马上开始我们的准备工作！"><a href="#二、-话不多说，马上开始我们的准备工作！" class="headerlink" title="二、 话不多说，马上开始我们的准备工作！"></a>二、 话不多说，马上开始我们的准备工作！</h2><ul><li><p>GitHub</p><ul><li>首先得有个账号：<a href="https://github.com/" title="GitHub主页">注册GitHub</a>  </li><li><a href="https://desktop.github.com/" title="GitHub客户端" target="_blank" rel="external"> 下载GitHub客户端</a>GitHub客户端（方便对项目的管理）， 安装完成后，会在桌面上出现两个图标，<code>git Shell</code>（所以就直接可以用）和<code>GitHub</code></li></ul></li><li><p>NodeJS</p><ul><li>既然是使用nodejs开发的，就少不了nodejs，so..<a href="https://nodejs.org/en/" title="nodejs官网" target="_blank" rel="external">下载nodejs</a>，选择对应自己电脑的版本下载安装。为方便管理，我选择下载在D盘下创建文件夹名为<code>nodejs</code>或<code>node</code> 的文件夹中。</li><li>打开cmd输入 <code>node -v</code>，出现版本号说明安装成功</li></ul><ul><li><p>hexo安装</p><ul><li><p>首先创建文件夹名为blog ，我们要将hexo下载在此目录</p></li><li><p>打开git shell 或 git，输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">D:\&gt;cd blog</div><div class="line">D:\blog&gt;npm install hexo-cli -g</div></pre></td></tr></table></figure></li></ul></li></ul></li></ul><pre><code>稍等一会儿就会显示 `added XXX packages in XX.XXXs` 成功 - 检查是否安装成功在cmd或git shell中输入`hexo -v` 出现版本信息即为成功</code></pre><hr><h2 id="三、创建项目"><a href="#三、创建项目" class="headerlink" title="三、创建项目"></a>三、创建项目</h2><ul><li>hexo初始化<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">D:\blog&gt;hexo init</div></pre></td></tr></table></figure></li></ul><p>   初始化成功：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">INFO  Copying data to D:\blog</div><div class="line">INFO  You are almost done! Don&apos;t forget to run &apos;npm install&apos; before you  start blogging with Hexo!</div></pre></td></tr></table></figure></p><ul><li><p>依赖包的安装</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">D:\blog&gt;npm install</div></pre></td></tr></table></figure><p> 此时查看你的blog目录结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">blog</div><div class="line">├── _config.yml</div><div class="line">├── node_modules</div><div class="line">├── package.json</div><div class="line">├── scaffolds</div><div class="line">├── source</div><div class="line">|    └── _posts</div><div class="line">└── themes</div></pre></td></tr></table></figure><p> 好玩的部分马上就到了，继续咯~ </p><hr></li><li><p>创建文章 （很鸡冻の部分有木有！！）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">D:\blog&gt;hexo new &quot;hello world&quot;</div></pre></td></tr></table></figure><p>   可简写为：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">D:\blog&gt;hexo n &quot;hello world&quot;</div></pre></td></tr></table></figure><p> 创建成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"> INFO Created: D:\blog\source\_posts\hello-world.md</div><div class="line"> ``` </div><div class="line"> --------</div><div class="line">- 页面生成&amp;运行</div><div class="line"></div><div class="line">      - 修改内容，打开`hello-world.md：`</div></pre></td></tr></table></figure><p>   —title: hello world date:xxxx-xx-xx xx:xx:xx tags:—</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">在文章最后的- - -后面写下一些简单的句子，ctrl+s保存一下下</div><div class="line"></div><div class="line">      - 生成页面</div></pre></td></tr></table></figure><p> D:\blog&gt;hexo generate</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">可简写为：</div></pre></td></tr></table></figure><pre><code>D:\blog&gt;hexo g </code></pre>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- 跑跑跑，让它跑起来</div></pre></td></tr></table></figure><pre><code>D:\blog&gt;hexo  server</code></pre>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">当然此处也有简写：</div></pre></td></tr></table></figure><pre><code>D:\blog&gt;hexo  s <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">结果：</div></pre></td></tr></table></figure>INFO Start processing INFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.</code></pre><p>  ```</p><p> <strong>* 以上端口号仅供参考，具体端口号请结合自己的实际情况</strong></p><p> 在浏览器中打开以上网址就可以看到我们刚刚建好的<strong>hello-world</strong> 文章了， 放眼望去，博客名怎么叫hexo，什么嘛，作者信息也不是我，迫不及待要改改改有木有！ 继续！</p></li></ul><hr><h2 id="四、配置信息"><a href="#四、配置信息" class="headerlink" title="四、配置信息"></a>四、配置信息</h2><p>   用你的编辑器打开blog文件夹<strong>根目录</strong>下的配置文件 <code>_config.yml</code> ， 找到 <code>#site</code> 这个部分，在<code>title :</code> 的后面改成你喜欢的博客名。<code>author</code> 也是你啦，<code>email</code> 、<code>description</code> 都可以随意添上点内容。<br>   语言选项 <code>language：zh-Hans</code> (<strong>简体中文</strong>)</p><p>   <strong>注意：XXXXX: 与其值之间必须有一个空格</strong></p><p>   更多详细信息请参考：<a href="https://hexo.io/docs/configuration.html" title="hexo官方文档" target="_blank" rel="external">hexo官方文档</a></p><p>参考文章：</p><p>❤ <a href="http://www.jianshu.com/p/b06222fbc135" title="参考文章1" target="_blank" rel="external">用Hexo创建个人博客</a><br>❤ <a href="http://blog.csdn.net/gdutxiaoxu/article/details/53576018" title="参考文章2" target="_blank" rel="external">手把手教你用Hexo+Github 搭建属于自己的博客</a></p><hr><p>ps：这是<a href="https://github.com/MonicaDan" title="MonicaDan的GitHub">我的GitHub</a>， 请多关照， よろしく ~~ ❤❤</p><p>我要去休息啦，所以今天要到此为止咯，更多细节就在以后的博客中更新~~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  大家好！我是MonicaDan！ 前几天使用了hexo和GitHub创建属于自己的博客，这就算是一个总结吧~ 开始咯~~&lt;/p&gt;
    
    </summary>
    
      <category term="web dev" scheme="https://github.com/MonicaDan/monicadan.github.com.git/categories/web-dev/"/>
    
    
      <category term="hexo" scheme="https://github.com/MonicaDan/monicadan.github.com.git/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>辨析 Sass 中的 Map 和 List</title>
    <link href="https://github.com/MonicaDan/monicadan.github.com.git/2015/10/21/demo/"/>
    <id>https://github.com/MonicaDan/monicadan.github.com.git/2015/10/21/demo/</id>
    <published>2015-10-21T02:34:12.000Z</published>
    <updated>2017-10-10T13:42:16.130Z</updated>
    
    <content type="html"><![CDATA[<p>如果你使用过 Sass 3.3 之前的版本，那么你一定对那段时光颇有感触，那时候没有现如今这么好的条件，那时候的 Map 还只能用多重列表（lists of list）来模拟。多重列表可以实现复杂数据的嵌套定义，但却不是以键值对的形式实现的，所有当我们需要获取其中特定的某一项时就会比较麻烦。Map 这种数据类型天生就是基于键值对的形式，非常便于组织数据。</p><p>自从可以使用 Map 之后，开发者们开始毫无顾忌地定义 Map 存储数据，比如断点宽度、颜色值、栅格布局等等响应式排版的细节，都被一股脑的塞进了 Map 中。</p><p>那么，有了 Map 之后，我们还有必要使用 List 吗？可能某些人会觉得为了保持向后兼容应该继续使用多重列表模拟 Map，因为可能有些开发者仍然在使用老版本的 Sass 编译器，但实际上，这是多此一举了，Sass 的版本通常由 <code>package.json</code> 或者其他同类型的项目配置文件所控制，往往只需一条命令（<code>gem update sass</code>）即可更新 Sass 的版本，因此基本上无需考虑对老版本的兼容问题。</p><a id="more"></a><p>使用多重列表替代 Map 的优势之一就是减少代码量。下面让我们来比较一下多种列表和 Map 的语法结构以及遍历方式。</p><h2 id="测试表格"><a href="#测试表格" class="headerlink" title="测试表格"></a>测试表格</h2><table><thead><tr><th>Variable</th><th>Description</th></tr></thead><tbody><tr><td><code>site</code></td><td>Sitewide information.</td></tr><tr><td><code>page</code></td><td>Page specific information and custom variables set in front-matter.</td></tr><tr><td><code>config</code></td><td>Site configuration</td></tr><tr><td><code>theme</code></td><td>Theme configuration. Inherits from site configuration.</td></tr><tr><td><code>_</code> (single underscore)</td><td><a href="http://lodash.com/" target="_blank" rel="external">Lodash</a> library</td></tr><tr><td><code>path</code></td><td>Path of current page</td></tr><tr><td><code>url</code></td><td>Full URL of current page</td></tr><tr><td><code>env</code></td><td>Environment variables</td></tr></tbody></table><h2 id="语法比较"><a href="#语法比较" class="headerlink" title="语法比较"></a>语法比较</h2><div class="note"><br>    <h5>测试标题</h5><br>    <p>在下面的示例中，我创建了一个用于控制响应式布局的数据，该数据一共有四个断点，每一个断点都包含了 <code>min-width</code>、<code>max-width</code>、<code>font-size</code> 和 <code>line-height</code> 四个样式。</p><br></div><h4 id="Map-语法"><a href="#Map-语法" class="headerlink" title="Map 语法"></a>Map 语法</h4><p>下面就是使用 Map 存储的数据，具体来说，该 Map 中首先存储了四个用于标识断点的 Key，相对应的是保存具体属性值得 Value。虽然这种形式可读性更高，但是总体代码量却高达 26 行 450 个字符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">$breakpoint-map: (</div><div class="line">    small: (</div><div class="line">        min-width: null,</div><div class="line">        max-width: 479px,</div><div class="line">        base-font: 16px,</div><div class="line">        vertical-rhythm: 1.3</div><div class="line">    ),</div><div class="line">    medium: (</div><div class="line">        min-width: 480px,</div><div class="line">        max-width: 959px,</div><div class="line">        base-font: 18px,</div><div class="line">        vertical-rhythm: 1.414</div><div class="line">    ),</div><div class="line">    large: (</div><div class="line">        min-width: 960px,</div><div class="line">        max-width: 1099px,</div><div class="line">        base-font: 18px,</div><div class="line">        vertical-rhythm: 1.5</div><div class="line">    ),</div><div class="line">    xlarge: (</div><div class="line">        min-width: 1100px,</div><div class="line">        max-width: null,</div><div class="line">        base-font: 21px,</div><div class="line">        vertical-rhythm: 1.618</div><div class="line">    )</div><div class="line">);</div></pre></td></tr></table></figure><h4 id="多重列表语法"><a href="#多重列表语法" class="headerlink" title="多重列表语法"></a>多重列表语法</h4><p>下面的多重列表存储了和上面 Map 同样的数据，在多重列表中没有 Key-Value 的对应关系，这意味着要想找到特定的值，必须使用遍历或 <code>nth()</code> 的方式来实现了。从另一个角度来看，多种列表又比 Map 的代码量小得多，总共只有六行 180 个字符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$breakpoint-list: (</div><div class="line">    (small, null, 479px, 16px, 1.3),</div><div class="line">    (medium, 480px, 959px, 18px, 1.414),</div><div class="line">    (large, 960px, 1099px, 18px, 1.5),</div><div class="line">    (xlarge, 1100px, null, 21px, 1.618)</div><div class="line">);</div></pre></td></tr></table></figure><h2 id="遍历比较"><a href="#遍历比较" class="headerlink" title="遍历比较"></a>遍历比较</h2><div class="note info"><br>    <h5>测试标题</h5><br>    <p>从上面简单地比较中可以粗略的看出，多种列表的代码量明显少于 Map。但是，如果我们需要遍历这些值得话，复杂度又是怎样的呢？</p><br></div><h4 id="遍历-Map"><a href="#遍历-Map" class="headerlink" title="遍历 Map"></a>遍历 Map</h4><p>我们可以使用如下的代码遍历 Map：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@each $label, $map in $breakpoint-map &#123;&#125;</div></pre></td></tr></table></figure><p>这里的变量 <code>$label</code> 和 <code>$map</code> 会随着对 <code>$breakpoint-map</code> 的遍历被动态地赋值，<code>$label</code> 将会被赋值为 <code>$breakpoint-map</code> 的 Key，而 <code>$map</code> 会被赋值为 <code>$breakpoint-map</code> 的 Value。为了在遍历过程中获取特定值，我们就需要使用 Sass 原生的 <code>map-get()</code> 函数，使用该函数需要传入两个参数：Map 的名字和求取的 Key，最后返回该 Map 中匹配该 Key 的 Value。</p><p>具体的做法就是使用 <code>@each</code> 遍历 Map，然后使用 <code>map-get()</code> 获取特定值，最终只需要六行代码 220 个字符即可完成整个遍历：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@each $label, $map in $breakpoint-map &#123;</div><div class="line">    $min-width: map-get($map, min-width);</div><div class="line">    $max-width: map-get($map, max-width);</div><div class="line">    $base-font: map-get($map, base-font);</div><div class="line">    $vertical-rhythm: map-get($map, vertical-rhythm);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="遍历多重列表"><a href="#遍历多重列表" class="headerlink" title="遍历多重列表"></a>遍历多重列表</h4><p>遍历多重列表不必像遍历 Map 一样动态获取到 Map 后再使用 <code>map-get()</code> 函数取特定值，直接遍历一遍即可获得特定值。</p><p>因为多种列表内层的每一个列表结构相同，都有按照相同顺序排列的五个值，所以我们可以持续遍历每个值并赋值给特定的变量。无需调用 <code>map-get()</code>，直接引用这些变量即可进行赋值等裸机操作。最终遍历多重列表只使用了两行代码 100 个字符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@each $label, $min-width, $max-width, $base-font, $vertical-rhythm in $breakpoint-list &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="慎用多重列表"><a href="#慎用多重列表" class="headerlink" title="慎用多重列表"></a>慎用多重列表</h2><div class="note warning"><br>    <h5>测试标题</h5><br>    <p>经过上述的比对，看起来多重列表各方面都在碾压 Map，实则不然，Sass 中添加 Map 有一条非常重要的原因就是：Key-Value 的映射关系。</p><br></div><h4 id="遗漏键值"><a href="#遗漏键值" class="headerlink" title="遗漏键值"></a>遗漏键值</h4><p>如果要使用多重列表，那么就必须保证自己非常熟悉多重列表内部的每一项所代表的意义。下面我们举个例子，来看看遗漏了某些值的情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">$breakpoint-list: (</div><div class="line">    (small, null, 479px, 16px, 1.3),</div><div class="line">    (medium, 480px, 959px, 18px, 1.414),</div><div class="line">    (large, 960px, 1099px, 18px, 1.5),</div><div class="line">    (xlarge, 1100px, 21px, 1.618)</div><div class="line">);</div><div class="line"></div><div class="line">p &#123;</div><div class="line">    @each $label, $min-width, $max-width, $base-font, $vertical-rhythm in $breakpoint-list &#123;</div><div class="line">        @if $min-width &#123;</div><div class="line">            @include breakpoint( $min-width ) &#123;</div><div class="line">                font-size: $base-font;</div><div class="line">                line-height: $vertical-rhythm;</div><div class="line">            &#125;</div><div class="line">        &#125; @else &#123;</div><div class="line">            font-size: $base-font;</div><div class="line">            line-height: $vertical-rhythm;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当我们尝试运行这段代码时，结果肯定是错误地，因为在 <code>$breakpoint-list</code> 的最后一行，<code>xlarge</code> 被赋值给了 <code>$label</code>，<code>1100px</code> 被赋值给了 <code>$min-width</code>，<code>21px</code> 被赋值给了 <code>$max-width</code>, <code>1.618</code> 被赋值给了 <code>$base-font</code>，最终导致 <code>$vertical-rhythm</code> 没有被赋值，结果就是 <code>font-size</code> 的属性值是错的，<code>line-height</code> 的属性值是空的。此外，Sass 还不会对此抛出错误，导致我们无从知晓错误所在。</p><p>如果我们使用 Map 来代替这里的多重列表，那么使用 <code>map-get()</code> 函数即使遇见空值也能正确获得想要的结果。这就是值得我们慎重思考的地方：多种列表虽然简单快速，但是丧失了 Map 中的容错能力和快速取值能力。</p><h4 id="查找特定列表"><a href="#查找特定列表" class="headerlink" title="查找特定列表"></a>查找特定列表</h4><p>在多重列表中查找特定列表简直就是一种折磨。如果使用 Map，那么配合 <code>map-get()</code> 函数可以快速定位到特定子 Map：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$medium-map: map-get($maps, medium);</div></pre></td></tr></table></figure><p>但如果要获取多种列表 <code>medium</code> 列表，麻烦可就大了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@function get-list($label) &#123;</div><div class="line">    @each $list in $breakpoint-list &#123;</div><div class="line">        @if nth($list, 1) == $label &#123;</div><div class="line">            @return $list;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    @return null;</div><div class="line">&#125;</div><div class="line">$medium-list: get-list(medium);</div></pre></td></tr></table></figure><p>这段代码的逻辑就是遍历整个多重列表，知道找到第一个匹配项，然后返回，如果一直没有找到匹配项，就一直遍历到末尾，然后返回 <code>null</code>。这实际上就是手工实现了 <code>map-get()</code> 的逻辑。</p><h4 id="缺少原生的-Map-函数"><a href="#缺少原生的-Map-函数" class="headerlink" title="缺少原生的 Map 函数"></a>缺少原生的 Map 函数</h4><p>Sass 提供了诸多的原生函数用于处理 Map 数据类型，但是多重列表是没法调用这些函数的，比如，使用 <code>map-merge()</code> 可以合并两个 Map，如果两个 Map 有相同的值，则取第二个 Map 的值为最终值。当然你也可以在多重列表中使用 <code>join()</code> 或 <code>append()</code> 来增加新列表，从而模拟出 <code>map-merge()</code> 的效果。</p><p>另一个实用的 Map 函数就是 <code>map-has-key()</code>，对于依赖 <code>map-get()</code> 的自定义函数来说，<code>map-has-key()</code> 可以用来验证特定的 Key 是否存在。但在列表中是完全没有相似的方法。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="note unreleased"><br>    <h5>Test Title</h5><br>    <p>相比起列表来说，Key-Value 模型的 Map 显然更有力量，原生的 Sass Map 函数更是提供了强力的数据查找和验证工具。</p><br></div><p>虽然多重列表代码量少，但并不能像 Map 一样进行错误检查或验证参数。在大多数时候，相比较多重列表而言，我相信 Map 是更好的选择。如果是为了更少的代码量和其他简单地调用，那么我偶尔会用用多重列表，但是从项目的宏观控制和数据存储方面显然更优秀。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果你使用过 Sass 3.3 之前的版本，那么你一定对那段时光颇有感触，那时候没有现如今这么好的条件，那时候的 Map 还只能用多重列表（lists of list）来模拟。多重列表可以实现复杂数据的嵌套定义，但却不是以键值对的形式实现的，所有当我们需要获取其中特定的某一项时就会比较麻烦。Map 这种数据类型天生就是基于键值对的形式，非常便于组织数据。&lt;/p&gt;
&lt;p&gt;自从可以使用 Map 之后，开发者们开始毫无顾忌地定义 Map 存储数据，比如断点宽度、颜色值、栅格布局等等响应式排版的细节，都被一股脑的塞进了 Map 中。&lt;/p&gt;
&lt;p&gt;那么，有了 Map 之后，我们还有必要使用 List 吗？可能某些人会觉得为了保持向后兼容应该继续使用多重列表模拟 Map，因为可能有些开发者仍然在使用老版本的 Sass 编译器，但实际上，这是多此一举了，Sass 的版本通常由 &lt;code&gt;package.json&lt;/code&gt; 或者其他同类型的项目配置文件所控制，往往只需一条命令（&lt;code&gt;gem update sass&lt;/code&gt;）即可更新 Sass 的版本，因此基本上无需考虑对老版本的兼容问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="css" scheme="https://github.com/MonicaDan/monicadan.github.com.git/tags/css/"/>
    
  </entry>
  
</feed>
